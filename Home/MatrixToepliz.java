package Home;
//766. Toepliz Matrix
//Учитывая m x n matrix, верните true, если матрица является матрицей Тёплица. В противном случае верните false.
//Матрица является матрицей Тёплица, если все значения в диагонали от верхнего левого до нижнего правого имеют одинаковые элементы.
//В матрице Тёплица каждая диагональ определяется разностью индексов i - j = const.
//Например:
//Главная диагональ: i - j = 0 (элементы (0,0), (1,1), (2,2)).
//Диагональ выше: i - j = -1 (элементы (0,1), (1,2), (2,3)).
//Диагональ ниже: i - j = 1 (элементы (1,0), (2,1)).
//Проверка диагоналей:
//Для каждого элемента (i, j) в матрице (кроме последней строки и последнего столбца) проверяем, что он равен элементу (i+1, j+1).
//Если хотя бы один элемент нарушает это условие → матрица не является матрицей Тёплица.
//Проверяем только элементы, у которых есть "сосед справа внизу"
// Заметка: матрицы с одной строкой или столбцом атоматически считаются матрицей Тёплица

public class MatrixToepliz {
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4}, {5, 1, 2, 3}, {9, 5, 1, 2}};
        if (isToeplizMatrix(matrix)) {
            System.out.println("Это Матрица Тёплица");
        } else {
            System.out.println("Эта матрица не является Матрицей Тёплица");
        }
    }

        public static boolean isToeplizMatrix ( int[][] matrix){
            // можно для удобства создать две переменные: для строк и для столбцов
            int rows = matrix.length;
            int columns = matrix[0].length;

            // поскольку матрица - двумерный массив, использую вложенный цикл for
            // вычитаем -1, т.к.: 1- чтобы не выйти за границы, когда будем идти по диагонали
            for (int i = 0; i < rows - 1; i++) {
                for (int j = 0; j < columns - 1; j++) {
                    if (matrix[i][j] != matrix[i + 1][j + 1]) {
                        if (matrix[i][j] != matrix[i + 1][j + 1]) {
                            return false;
                        }
                    }
                }
            }
            return true;
            // Этот подход имеет сложность O((n-1)(m-1))

        }
    }
